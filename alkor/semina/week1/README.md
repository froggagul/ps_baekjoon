최단경로
====

최단경로의 종류
* 하나의 정점에서 다른 하나의 정점
* 하나의 정점에서 다른 모든 정점
* 하나의 목적지로 가는 모든 최단 경로
* 모든 최단 경로

DFS/BFS
* DFS: O(V+E) (인접리스트 구현시)
* 모든 간선의 길이가 같다면 BFS를 이용하자
    * BFS: O(B+E) (인접리스트 구현시)

다익스트라
====
* 한 정점에서부터 다른 모든 정점으로의 최단 경로를 구하는 알고리즘
* **음수 사이클이 있으면, 최단 경로를 구할 수 없다.**
* 시간복잡도: O(V^2) (단순구현)

알고리즘
----
* bfs에서 queue -> priority queue, priority_queue에 넣는 값을 정점번호와 그 가중치로 변경

다익스트라 알고리즘의 증명
----
귀류법을 이용한다  
**음수 간선이 존재하지 않는 경우** 다익스트라 알고리즘이 최단거리를 정확하게 계산하지 못하는 정점 u가 있다고 가정하자
* 시작점에 대해서는, 항상 최단거리를 정확하게 계산하므로, u는 시작점이 아니다.
다익스트라 알고리즘이 정점 u를 방문하는 순간, u 이전에 방문한 정점들과 u이후에 방문한 정점들로 나눌 수 있다.
정점 u는 다익스트라 알고리즘이 최단거리를 정확하계 계산하지 못하기 때문에, 시작점 s에서 정점 u로 가는 최소 경로가 존재한다. 이 최소경로에서, u에서 가장 가까운 다익스트라 알고리즘이 방문한 정점을 p라 하고, p 다음점을 q라 하자.  
p는 이미 방문되었으므로, prioirty queue에 들어가있다. 이때, prioirty queue에서 u가 먼저 꺼내어 졌으므로, dist[q] >= dist[u]이다.  
즉, q를 지나서 오는 경로가 dist[u]보다 김을 의미하는데, 이는 초기 가정에 모순이다.  
따라서, 다익스트라 알고리즘은 최단거리를 정확하게 계산한다.  


벨만포드
====
* 음수 가중치를 가지는 간선이 있어도 원래 시간복잡도 안으로 작동한다.
* 시간복잡도 O(VE)
* d음수 사이클이 있어서 최단거리가 제대로 정의되지 않은 경우도 알려줌
    * n-1과 n번째 dist 배열을 비교해서 음수 사이클의 유무를 알 수 있음

플로이드-와샬
=====
* 모든 정점 쌍에 대해 둘 사이의 최단거리를 구해야 할때 사용된다.
* 다음의 코드를 사용한다.
    ```cpp
    for (int k=0;k<v;k++) {
        for (int i=0;j<v;j++) {
            for (int j=0;j<v;j++) {
                adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);
            }
        }
    }
    ```
* 가중치가 없는 그래프에 대해서 임의의 두정점이 이어져있는지를 점검할때도 사용된다.
    * 이 경우, min이 ||로, +가 &&로 변한다.
    * 이는 점화식을 유도해보면 금방 유추할 수 있다. (1613, 2158번 참고)

증명
----
* 점화식을 이용한다.
* (tbd)