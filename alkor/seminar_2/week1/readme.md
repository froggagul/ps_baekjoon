## 펜윅 트리: 구간 합 구하기
x를 이진수로 나타냈을때, 1인 가장 낮은 자릿수를 f(x)라 정의해보자
    * 펜윅트리의 x번째 칸은 f(x)개의 칸을 관리하며, [x - f(x) + 1, x]의 합을 저장합니다.
    * x-f(x)는 x의 1인 가장 작은 자리를 삭제하는 것과 같다. ex) 110 -> 100
    * 구간합이 O(logn)에 계산된다.

$f(12) = f(1100_2) = 100_2 = 4$
$f(9) = f(1001_2) = 1_2 = 1$

ex) 1~7까지의 합을 구하고 싶을때
* Sum(1, 5) = Sum(1,4) + Sum(5, 5)

### 값의 갱신
ex) 3번째 원소를 5로 바꾸고 싶다.
세그먼트 트리를 갱신해야 한다. -> x에 f(x)를 더해가며 그 값을 갱신하면 된다.

### f(x)의 갱신
```c++
int f(int x) {
    return (x & -x);
}
```

### 펜윅 트리의 장단점
장점 : 적은 구현량 및 빠른 연산 속도 세그먼트 트리로는 시간초과가 나는데, 펜윅 트리로는 통과하는 경우가 있을 수도?

단점 : 한정적인 기능만을 지원합니다. 구체적으로, 구간의 최소값 및 구간의 최대값 쿼리를 처리하지 못합니다. 이에 더해, 구간 갱신이 어렵습니다. 

## 세그먼트 트리
* 완전 이진 트리 형태의 자료구죠
    * 펜윅 트리는 N개의 수에 대해 2N-1 개가 필요하다.
    * 가장 위의 루트 노드가 1번, x번 노드의 왼쪽 자식은 2x, 오른쪽 자식은 2x+1번
### 구현
1. top down 구현: 재귀 기반 분할정복
2. bottom up 구현: 비재귀

### Top Down
* 구간 [a, b]를 관리하는 것
