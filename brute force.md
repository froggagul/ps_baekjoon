브루트 포스
====
brute force, 한국어로는 무차별 대입법으로 가능한 가짓수를 모두 해보는 방법이다.
사물함에 달린 네자리수 비밀번호를 알아내기 위해 0000부터 9999까지 전부 해보는 것이 무차별 대입법(brute force)에 해당한다.
그렇기에, 시간 제한을 신경써야 하는 풀이법이기도 하다.

1. 문제의 가능한 경우의 수를 계산해본다
    * 직접 계산을 통해서 구한다. 대부분 손으로 계산 가능하다.
2. 가능한 모든 방법을 다 만들어본다.
    * 누락되는 부분이 있지 말아야 한다.
    * 반복문, 순열, 재귀, 비트마스크를 사용할 수 있다.
3. 답을 계산하고, 비교해본다.

순열
====
* C++ STL의 algorithm에는 이미 next_permutation과 prev_permutation이 존재하기때문에 사용하면 된다
* 사전상 다음순열을 구하는 알고리즘
    1. A[i-1] < A[i]를 만족하는 가장 큰 i를 찾는다
        * 계속해서 감소하는 순열은 사전상 가장 뒤에 온다. 사전상에서 증가시키려면, 연속으로 증가하는 부분 중 가장 오른쪽에 있는 부분을 감소하는 형태로 만들어야 한다.
    2. j ≥ i 이면서 A[j] > A[i-1] 를 만족하는 가장 큰 j를 찾는다
    3. A[i-1]과 A[j]를 swap 한다
        * 사전순으로 증가시킬 때 사용할 수 있는 수는 순열에서 오른쪽으로 있는 수들이므로, 이들 중 가장 오른쪽에 있는 j번째 수를 가져와 i-1번째와 바꾼다.
    4. A[i]부터 끝까지의 순열을 뒤집는다
        * A[i-1]부터 가장 작은 사전상의 수열이 필요하므로, 순열을 뒤집어야 한다.
* 사전상 이전 순열을 구하려면 반대로 하면 된다.
    1. A[i-1] > A[i]를 만족하는 가장 큰 i를 찾는다.


비트마스크
====
말 그대로, 비트 연산을 사용해서 부분집합을 표현하는 것이다.  
and, or, not, xor, shift(left & right) 연산을 이용한다.
* 정수로 집합을 나타낼 수 있는데, 각 정수는 이진수의 자릿수로 치환되어 사용된다
    * ex) {1, 2, 3} = 2^1 + 2^2 + 2^3;
``` c++
// 현재 집합이 S일때
int S = 0;
// i를 추가
S | (1 << i);
// i를 검사, 결과 값이 0 이상이면 존재하는 것
S & (1 << i);
// i를 제거
S & ~(1 << i);
// i를 토글 (0을 1로, 1을 0으로)
S ^ (1 << i);
```
참고로 문제에서 1~N을 활용하는 경우, 이를 1씩 빼어 0 ~ N-1까지 사용하면, 메모리가 절반으로 줄어드는 효과를 볼 수 있다.

물론 배열을 사용하는 것이 더욱 편리하지만, 비트마스크를 사용하는 이유는 집합을 배열의 인덱스로 표현할 수 있기 때문이다.  
즉, 상태 다이나믹을 할 때 자주 사용하게 된다.