시간복잡도
====
* 코드의 시간에 소요되는 시간을 나타내는 표기법
* 표기법으로 대문자 O를 사용한다
* 입력의 크기 N에 대해서 시간이 얼마나 걸릴지 나타내는 방법
* 최악의 경우(경우의 확률에 상관없이)에 시간이 얼마나 걸릴지 알 수 있다.

ex) 다음의 경우를 생각해보자
* 총 N명의 사람이 식당에 방문했다
* 식당에는 메뉴가 M개 있고, 메뉴판이 1개 있다.
* 사람 1명이 메뉴판을 읽는데 걸리는 시간은 O(M)
* 주문한 메뉴는 동시에 나오며 각 사람i가 식사를 하는데 걸리는 시간은 Ai
* 각 사람이 계산을 하는데 걸리는 시간은 O(P)이다.

이로부터 알 수 있는 정보들은 다음과 같다. 
* 각 사람이 메뉴판에 있는 모든 메뉴를 읽는 시간 복잡도 = O(NM)
* 모든 사람이 식사를 마치는데 걸리는 시간 = O(max(Ai))
  * 최악의 경우에 걸리는 시간이기 때문이다.
* 식사를 모두 마친 다음 한줄로 서서 각자 계산을 하는 시간 복잡도 = O(NP)

ex) 코드를 통해 알아보자 다음은 1부터 N까지의 합을 계산하는 소스이다.
```c
int sum = 0;
for (int i = 1; i <= N; i++) {
    sum += i;
}
```
다음의 시간복잡도는 O(N)이다. N번의 더하기가 이루어지기 때문이다.
```c
int sum = 0;
for (int i = 1; i <= N; i++) {
    for (int j = 1 ; j <= N; j++) {
        if (i == j) {
            sum += j;
        }
    }
}
```
다음의 시간복잡도는 O(N^2)이다. N번 더하는 루프가 N번 반복되기 때문이다.
```
int sum = 0;
sum = N * (N + 1) / 2;
```
다음의 시간복잡도는 O(1)이다. 바로 계산 가능하기 때문이다.

시간 복잡도 안에 가장 큰 입력 범위를 넣었을때, 1억이 1초 정도이다. 문제의 제한을 보고 어떤 방법까지 생각할지를 미리 결정할 수 있다.  
N의 제한이 500인 경우, O(N^2*logN)정도까지도 생각해볼 수 있다. 대략적인 전략을 짤 수 있다.
  * 문제의 크기에 따라 알고리즘이 달라지기 때문.
  * 10명이 접속하는 사이트와 10만명이 접속하는 사이트를 만드는 방법은 큰 차이가 있다.

* 시간 복잡도를 표기할때 주의할 것
  * 상수는 버린다 O(3*N^2) = O(N^2)
  * O(5) = O(1)
* 두가지 항이 있을때, 변수가 같으면 큰 것만 빼고 다 버린다.
  * O(N^2 + N) = O(N^2)
* 단, 두가지 항에 해당하는 변수가 다르면 생략하지 않는다.
  * O(N^2 + M)는 놔둔다.

메모리
====
* 메모리 제한은 보통 넉넉하기 때문에, 걱정할 필요가 적다.
* 대략적으로 얼마나 공간을 사용할지 예상할 수는 있다.
* 보통 공간을 가장 많이 사용하는 것은 배열이다.
  * ```c
    int a[10000][10000]; 
    // 의 크기는 10000*10000*4B = 381.469MB
    ```
* 보통 배열의 크기가 크면 시간 초과를 받는 경우가 많다.
* 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.

입/출력
====
C++
* scanf printf, cin, cout
  * cin cout은 scanf/printf보다 느리기 때문에, 입출력이 많다면 scanf/printf를 사용하는 것이 좋다.
  * cout을 사용하는 경우 \n을 쓰는 것이 endl보다 훨씬 빠르다.
  * 다음 코드와 함께라면 더 빠르다!
  ```c++
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);
  ```
C
* scanf,printf

Java
* 입력은 scanner, 출력은 System.out
* 입력이 많은 경우 속도가 느리기 때문에 bufferedreader를 사용

* scanf의 리턴값은 성공적으로 입력받은 변수의 개수이다.