다이나믹 프로그래밍
=====
* 큰 문제를 작은 문제로 나누어 푸는것, 두가지 알고리즘이 있다.
    1. DP
    2. 분할 정복: Divide & conquer (D&C)
* 이 둘의 차이는 나눈 문제의 중복의 유무이다.
    * DP는 중복이 존재, 분할정복은 존재 X
* 단, 다음의 두가지 속성을 만족해야 다이나믹 프로그래밍으로 풀 수 있다.
    1. Overlapping Subproblem(겹치는 부분 문제)
        * 예를들어, 피보나치 수열에서 N번째 피보나치 수를 구하는 문제는 N-1번째와 N-2번째 피보나치 수를 구하는 문제로 나누어 진다
        * A_n=A_(n-1) + A_(n-2)이기 때문에 겹치는 작은 문제들로 나누어졌다.
    2. Optimal Substructure(최적 부분 구조)
        * 예를들어, 서울에서 대전을 통해 부산을 가는 가장 빠른 길을 구한다고 하자. 서울에서 대전, 대전에서 부산을 가는 가장 빠른 길을 각각 구해야 한다. 
        * 겹치지 않는 작은 문제들로 나누어짐
* 특성
    * 각 문제는 단 한번만 풀어야 한다.
    * 정답은 항상 같기 때문에, 한번 정답을 구하면 어딘가에 저장해놓고 계속 이를 쓰면 된다.
    * 이를 Memoization이라 한다.(어딘가에 memo한다는 뜻)

* 피보나치 수열로 보는 재귀 vs DP
    ``` c++
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n-1) + fibonacci(n-2);
        }
    }
    ```  
    * 위 코드 에서는 겹치는 호출이 생긴다. 시간복잡도도 O(2^N)이다.
    ``` c++
    int memo[100];
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            if (memo[n] > 0) {
                return memo[n];
            }
            memo[n] = fibonacci(n-1) + fibonacci(n-2);
            return memo[n];
        }
    }
    ```
    * 위 코드에서는 겹치는 호출이 생기지 않고, 시간복잡도는 O(N)이다. (모든 문제를 1번씩 풀기 때문에, 문재의 개수 * 문제 1개를 푸는 시간이 복잡도)
* 그래서 어떻게 구현할 것인가?
    1. Top-down
        * 재귀 방식으로 하나하나 쪼개는것
    2. bottom-up
        * 문제를 크기가 작은 문제부터 차례대로 푼다
        * 문제의 크기를 조금씩 크게 만들면서 푼다.
        * 작은 문제를 풀면서 왔기에, 큰 문제도 풀 수 있다,
        * 가장 큰 문제를 마지막에 푼다.
        * 주로 반복문 사용
* 점화식을 정의하는것이 중요하다.